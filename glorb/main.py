from __future__ import annotations

import click
import yaml
import os
import hashlib
from typing import *

from .source import Source
from .updatable_source import UpdatableSource
from .dir_source import DirSource
from .url_source import URLSource

"""
Terminology:
    Segment: Path from the project or source root.
        Local: Path from the project root.
        Source: Path or reference from the source root.
    UID: 
        Local: Unique identifier for a particular project file.
        Source: Unique identifier for a particular source entry.
        These are not necessarily the same format and cannot be directly compared!
"""

if not os.path.isfile("glorb.yaml"):
    print(f"Could not find glorb.yaml in {os.getcwd()}.")
    exit(1)

with open("glorb.yaml", "rb") as f:
    config = yaml.safe_load(f.read())


def merge_dicts(a: Dict, b: Dict) -> Dict:
    merged = {**a}

    for k in b:
        if k in a and isinstance(a[k], dict) and isinstance(b[k], dict):
            merged[k] = merge_dicts(a[k], b[k])
        else:
            merged[k] = b[k]

    return merged


try:
    with open("glorboverrides.yaml", "rb") as f:
        config_overrides = yaml.safe_load(f.read())

    config = merge_dicts(config, config_overrides)
except FileNotFoundError:
    pass

has_git = os.path.isdir(".git")

GITIGNORE_MESSAGE = \
    """# +---------------------------------------------------------------------------------+
# | This file is AUTOGENERATED. ANY CHANGES made to this file will NOT BE RETAINED. |
# +---------------------------------------------------------------------------------+"""


def write_gitignore(segments: List[str]):
    with open("glorb.gitignore", "w") as f:
        f.write(GITIGNORE_MESSAGE + "\n\n")

        for segment in segments:
            f.write(segment + "\n")

        f.write("\n")

        f.write(GITIGNORE_MESSAGE)


class GlorbEntry:
    def __init__(self, uid: str, source_name: str, segment_override: str = None):
        self.uid: str = uid
        self.source_name: str = source_name
        self.segment_override: str = segment_override

    @property
    def source_segment(self):
        return self.uid if self.segment_override is None else self.segment_override

    @staticmethod
    def from_dict(v: Dict) -> GlorbEntry:
        return GlorbEntry(**v)

    def to_dict(self) -> Dict:
        return {
            "uid": self.uid,
            "source_name": self.source_name,
            "segment_override": self.segment_override,
        }


def read_glorbfile() -> Dict[str, GlorbEntry]:
    uid_entry_map = {}

    try:
        with open("glorbfile.yaml", "rb") as f:
            data = yaml.safe_load(f.read())

            if data is None:
                return {}

            for entry in data:
                uid_entry_map[entry["uid"]] = GlorbEntry.from_dict(entry)
    except FileNotFoundError:
        return {}

    return uid_entry_map


def write_glorbfile(uid_entry_map: Dict[str, GlorbEntry]) -> None:
    with open("glorbfile.yaml", "w") as f:
        data = [entry.to_dict() for entry in uid_entry_map.values()]

        yaml.safe_dump(data, f)


uid_entry_map = read_glorbfile()


def hash_file(path: str, chunk_size: int = 8192):
    h = hashlib.sha256()
    with open(path, "rb") as f:
        while chunk := f.read(chunk_size):
            h.update(chunk)

    return h


# class ZipSource(Source):
#     DATA_ROOT = "data/"
#
#     def __init__(self, path: str):
#         self.zipfile = zipfile.ZipFile(path, "a")
#
#     # def fetch(self, relative_path: str, to_path: str):
#         # self.zipfile.extract(from_path, os.path.join(ZipSource.DATA_ROOT, relative_path))
#
#     def push(self, from_path: str, relative_path: str):
#         self.zipfile.write(from_path, os.path.join(ZipSource.DATA_ROOT, relative_path))


def segment_to_uid(segment: str) -> str:
    return os.path.normpath(segment)


@click.group()
def cli():
    pass


T = TypeVar("T")


def try_get(d: Dict[str, T], key: str, message: str = "", exit_code: int = 1) -> T:
    try:
        return d[key]
    except KeyError:
        print(message)
        exit(exit_code)


def try_get_default(d: Dict[str, T], key: str, default: T) -> T:
    try:
        return d[key]
    except KeyError:
        return default


def prompt_confirm(message: str = "Are you sure you want to do that? (y/n)\n"):
    while True:
        response = input(message)
        if response == "y" or response == "Y":
            return
        if response == "n" or response == "N":
            print("Aborted.")
            exit(1)


name_source_map = {
    "dir": DirSource,
    "url": URLSource,
}


def get_source(source_name: str) -> Source:
    sources = try_get(config, "sources", "Missing entry \"sources\".")
    source_dict = try_get(sources, source_name, f"No source with name {source_name}")
    type_ = try_get(name_source_map, source_dict["type"],
                    f"Unrecognised source type {source_dict['type']}.")

    return type_.from_dict(source_dict)


def get_segment_uid(path: str):
    segment = os.path.relpath(path, os.getcwd())
    return segment, segment_to_uid(segment)


def get_path_uid(path: str):
    _, uid = get_segment_uid(path)
    return os.path.join(os.getcwd(), uid), uid


@cli.command()
@click.argument("path", type=click.Path(dir_okay=False))
@click.argument("source_name")
@click.option("--segment-override", type=str, default=None)
def add(path, source_name, segment_override):
    source = get_source(source_name)

    path, uid = get_path_uid(path)
    source_segment = uid if segment_override is None else uid

    if uid in uid_entry_map:
        print(f"File {path} already tracked in source {uid_entry_map[uid].source_name}.")
        exit(1)

    if os.path.exists(path):
        if isinstance(source, UpdatableSource):
            source.push(path, source_segment)
    else:
        if source.maybe_has_entry(source_segment):
            source.pull(path, source_segment)

    uid_entry_map[uid] = GlorbEntry(uid, source_name, segment_override)

    write_glorbfile(uid_entry_map)

    if has_git:
        write_gitignore(list(uid_entry_map.keys()))


@cli.command()
@click.argument("path", type=click.Path())
def untrack(path: str):
    # segment = os.path.relpath(path, os.getcwd())
    # uid = segment_to_uid(segment)

    path, uid = get_path_uid(path)

    source_name = try_get(uid_entry_map, uid, f"File {path} not tracked.").source_name
    source = get_source(source_name)

    if isinstance(source, UpdatableSource):
        source.remove(uid)

    del uid_entry_map[uid]

    write_glorbfile(uid_entry_map)

    if has_git:
        write_gitignore(list(uid_entry_map.keys()))


@cli.command()
@click.argument("path", type=click.Path(dir_okay=False))
@click.option("--force/--no-force", type=bool, default=False)
def pull(path, force):
    path, local_uid = get_path_uid(path)
    entry = try_get(uid_entry_map, local_uid, f"File {path} not tracked.")
    source_segment = entry.source_segment

    source = get_source(entry.source_name)

    if (os.path.exists(path)
            and source.compare_modification_time(source_segment, os.path.getmtime(path)) == -1
            and not force):
        prompt_confirm(
            "The file to pull to has a later modification date than the source file. Are you sure you want to overwrite it? (y/n)\n")

    source.pull(path, local_uid)


@cli.command()
@click.argument("path", type=click.Path(exists=True, dir_okay=False))
@click.option("--force/--no-force", type=bool, default=False)
def push(path, force):
    # _, uid = get_segment_uid(path)
    #
    # source_name = try_get(uid_entry_map, uid, f"File {path} not tracked.").source_name
    # source = get_source(source_name)

    path, local_uid = get_path_uid(path)
    entry = try_get(uid_entry_map, local_uid, f"File {path} not tracked.")
    source_segment = entry.source_segment

    source = get_source(entry.source_name)

    if not isinstance(source, UpdatableSource):
        print(f"File {path} is stored in source type {type(source)}, which does not support pushing.")
        exit(1)

    if source.compare_modification_time(source_segment, os.path.getmtime(path)) == 1 and not force:
        prompt_confirm(
            "The source file has a later modification date than the file to push. Are you sure you want to overwrite it? (y/n)\n")

    source.push(path, source_segment)


@cli.command
@click.option("--skip-sources", type=str, default="")
@click.option("--skip-types", type=str, default="")
def sync(skip_sources: str, skip_types: str):
    sources_to_skip = skip_sources.split(",")
    types_to_skip = skip_types.split(",")

    for uid, entry in uid_entry_map.items():
        path = os.path.join(os.getcwd(), uid)

        if entry.source_name in sources_to_skip:
            continue

        source = get_source(entry.source_name)

        if config["sources"][entry.source_name]["type"] in types_to_skip:
            continue

        source_segment = entry.source_segment

        comparison = source.compare_modification_time(source_segment, os.path.getmtime(path))

        if comparison == 1:  # source newer
            source.pull(path, source_segment)
            print(f"PULLED \"{uid}\"")
        elif comparison == -1 and isinstance(source, UpdatableSource):  # local newer
            source.push(path, source_segment)
            print(f"PUSHED \"{uid}\"")


if __name__ == '__main__':
    cli()
