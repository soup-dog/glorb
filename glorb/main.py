from __future__ import annotations

import click
import yaml
import shutil
import zipfile
from abc import ABC, abstractmethod
import os
import hashlib
from typing import *


if not os.path.isfile("glorb.yaml"):
    print(f"Could not find glorb.yaml in {os.getcwd()}.")
    exit(1)

with open("glorb.yaml", "rb") as f:
    config = yaml.safe_load(f.read())


has_git = os.path.isdir(".git")


GITIGNORE_MESSAGE = \
    """# +---------------------------------------------------------------------------------+
# | This file is AUTOGENERATED. ANY CHANGES made to this file will NOT BE RETAINED. |
# +---------------------------------------------------------------------------------+"""


def write_gitignore(segments: List[str]):
    with open("glorb.gitignore", "w") as f:
        f.write(GITIGNORE_MESSAGE + "\n\n")

        for segment in segments:
            f.write(segment + "\n")

        f.write("\n")

        f.write(GITIGNORE_MESSAGE)


def read_glorbfile():
    uid_source_map = {}

    try:
        with open("glorbfile", "r") as f:
            for line in f.readlines():
                split_index = line.index(" ")
                uid = line[:split_index]
                source = line[split_index + 1:-1]
                uid_source_map[uid] = source
    except FileNotFoundError:
        return {}

    return uid_source_map


def write_glorbfile(segment_source_map: Dict[str, str]):
    with open("glorbfile", "w") as f:
        for segment, source in segment_source_map.items():
            f.write(segment + " " + source + "\n")


uid_source_map = read_glorbfile()


def hash_file(path: str, chunk_size: int = 8192):
    h = hashlib.sha256()
    with open(path, "rb") as f:
        while chunk := f.read(chunk_size):
            h.update(chunk)

    return h


class Source(ABC):
    @staticmethod
    @abstractmethod
    def from_dict(v: Dict) -> Source:
        raise NotImplementedError()

    @abstractmethod
    def pull(self, to_path: str, segment: str):
        raise NotImplementedError()

    @abstractmethod
    def push(self, from_path: str, segment: str):
        raise NotImplementedError()

    @abstractmethod
    def has_entry(self, segment: str) -> bool:
        raise NotImplementedError()

    @abstractmethod
    def remove(self, segment: str) -> None:
        raise NotImplementedError()

    @abstractmethod
    def get_modification_time(self, segment: str) -> float:
        raise NotImplementedError()


class ZipSource(Source):
    DATA_ROOT = "data/"

    def __init__(self, path: str):
        self.zipfile = zipfile.ZipFile(path, "a")

    # def fetch(self, relative_path: str, to_path: str):
        # self.zipfile.extract(from_path, os.path.join(ZipSource.DATA_ROOT, relative_path))

    def push(self, from_path: str, relative_path: str):
        self.zipfile.write(from_path, os.path.join(ZipSource.DATA_ROOT, relative_path))


class DirSource(Source):
    def __init__(self, root: str):
        self.root: str = root
        self.data_root: str = os.path.join(root, "data/")
        # self.hashes_path: str = os.path.join(root, "glorbhash")
        # self.hashes: Dict[str, str] = self.read_hashes()
        os.makedirs(self.data_root, exist_ok=True)

    @staticmethod
    def from_dict(v: Dict) -> DirSource:
        return DirSource(v["path"])

    # def read_hashes(self) -> Dict[str, str]:
    #     if not os.path.exists(self.hashes_path):
    #         return {}
    #
    #     hashes = {}
    #
    #     with open(self.hashes_path, "r") as f:
    #         for line in f.readlines():
    #             split_index = line.index(" ")
    #             h = line[:split_index]
    #             uid = line[split_index + 1:-1]
    #             hashes[uid] = h
    #
    #     return hashes
    #
    # def write_hashes(self):
    #     with open(self.hashes_path, "w") as f:
    #         for uid, h in self.hashes.items():
    #             f.write(h + " " + uid + "\n")

    def pull(self, to_path: str, segment: str):
        source_path = self.segment_to_path(segment)
        shutil.copy(source_path, to_path)
        os.utime(to_path, (0, os.path.getmtime(source_path)))

    def push(self, from_path: str, segment: str):
        source_path = self.segment_to_path(segment)

        os.makedirs(os.path.dirname(source_path), exist_ok=True)

        shutil.copy(from_path, source_path)
        os.utime(source_path, (0, os.path.getmtime(from_path)))

        # self.hashes[segment_to_uid(segment)] = hash_file(from_path).hexdigest()
        # self.write_hashes()

    def segment_to_path(self, segment: str) -> str:
        return os.path.join(self.data_root, segment)

    def has_entry(self, segment: str) -> bool:
        return os.path.exists(self.segment_to_path(segment))

    def remove(self, segment: str):
        os.remove(self.segment_to_path(segment))
        # del self.hashes[segment_to_uid(segment)]
        # self.write_hashes()

    def get_modification_time(self, segment: str) -> float:
        return os.path.getmtime(self.segment_to_path(segment))


def segment_to_uid(segment: str) -> str:
    return os.path.normpath(segment)


@click.group()
def cli():
    pass


def try_get(d: Dict, key: str, message: str = "", exit_code: int = 1) -> Any:
    try:
        return d[key]
    except KeyError:
        print(message)
        exit(exit_code)


def try_get_default(d: Dict, key: Dict, default: Any) -> Any:
    try:
        return d[key]
    except KeyError:
        return default


def prompt_confirm(message: str = "Are you sure you want to do that? (y/n)\n"):
    while True:
        response = input(message)
        if response == "y" or response == "Y":
            return
        if response == "n" or response == "N":
            print("Aborted.")
            exit(1)


def get_source(source_name: str) -> Source:
    sources = try_get(config, "sources", "Missing entry \"sources\".")
    source_dict = try_get(sources, source_name, f"No source with name {source_name}")
    type_ = try_get({"dir": DirSource}, source_dict["type"],
                    f"Unrecognised source type {source_dict['type']}.")

    return type_.from_dict(source_dict)


@cli.command()
@click.argument("path", type=click.Path(exists=True, dir_okay=False))
@click.argument("source_name")
def add(path, source_name):
    source = get_source(source_name)

    segment = os.path.relpath(path, os.getcwd())
    uid = segment_to_uid(segment)

    if uid in uid_source_map.keys():
        print(f"File {path} already tracked in source {uid_source_map[uid]}.")
        exit(1)
    
    source.push(path, segment)

    uid_source_map[segment] = source_name

    write_glorbfile(uid_source_map)

    if has_git:
        write_gitignore(list(uid_source_map.keys()))


@cli.command()
@click.argument("path", type=click.Path())
def untrack(path: str):
    segment = os.path.relpath(path, os.getcwd())
    uid = segment_to_uid(segment)

    source_name = try_get(uid_source_map, uid, f"File {path} not tracked.")
    source = get_source(source_name)

    source.remove(segment)

    del uid_source_map[segment]

    write_glorbfile(uid_source_map)

    if has_git:
        write_gitignore(list(uid_source_map.keys()))


@cli.command()
@click.argument("path", type=click.Path(dir_okay=False))
@click.option("--force/--no-force", type=bool, default=False)
def pull(path, force):
    segment = os.path.relpath(path, os.getcwd())
    uid = segment_to_uid(segment)

    source_name = try_get(uid_source_map, uid, f"File {path} not tracked.")
    source = get_source(source_name)

    if (os.path.exists(path)
            and os.path.getmtime(path) > source.get_modification_time(segment)
            and not force):
        prompt_confirm("The file to pull to has a later modification date than the source file. Are you sure you want to overwrite it? (y/n)\n")

    source.pull(path, segment)


@cli.command()
@click.argument("path", type=click.Path(exists=True, dir_okay=False))
@click.option("--force/--no-force", type=bool, default=False)
def push(path, force):
    segment = os.path.relpath(path, os.getcwd())
    uid = segment_to_uid(segment)

    source_name = try_get(uid_source_map, uid, f"File {path} not tracked.")
    source = get_source(source_name)

    if source.get_modification_time(segment) > os.path.getmtime(path) and not force:
        prompt_confirm("The source file has a later modification date than the file to push. Are you sure you want to overwrite it? (y/n)\n")

    source.push(path, segment)


@cli.command
def sync():
    for uid, source_name in uid_source_map.items():
        path = os.path.join(os.getcwd(), uid)
        source = get_source(source_name)

        source_modification_time = source.get_modification_time(uid)
        local_modification_time = os.path.getmtime(path)

        if source_modification_time > local_modification_time:  # source newer
            source.pull(path, uid)
        elif local_modification_time > source_modification_time:  # local newer
            source.push(path, uid)


if __name__ == '__main__':
    cli()
